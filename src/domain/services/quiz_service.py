"""Quiz service for MathsFun application."""

from typing import List, Optional, NamedTuple
from datetime import datetime
from src.infrastructure.database.repositories.quiz_repository import QuizRepository
from ..models.quiz_session import QuizSession, QuizType, SessionStatus
from ..models.problem_attempt import ProblemAttempt


class QuizSessionResult(NamedTuple):
    """Result of a completed quiz session."""
    session: QuizSession
    attempts: List[ProblemAttempt]
    average_response_time: float
    fastest_correct_time: Optional[float]
    slowest_correct_time: Optional[float]


class UserProgress(NamedTuple):
    """User progress summary."""
    total_sessions: int
    total_problems: int
    total_correct: int
    overall_accuracy: float
    average_session_time: float
    best_accuracy: float
    recent_sessions: List[QuizSession]


class QuizService:
    """Service for quiz-related business logic."""
    
    def __init__(self, quiz_repository: QuizRepository):
        """Initialize service with quiz repository."""
        self.quiz_repo = quiz_repository
    
    def start_quiz_session(self, user_id: str, quiz_type: str, difficulty_level: int) -> Optional[QuizSession]:
        """Start a new quiz session."""
        session = QuizSession(
            id="",  # Will be generated by database
            user_id=user_id,
            quiz_type=QuizType(quiz_type),
            difficulty_level=difficulty_level,
            start_time=datetime.now(),
            total_problems=0,
            correct_answers=0,
            status=SessionStatus.ACTIVE
        )
        
        return self.quiz_repo.create_session(session)
    
    def record_answer(self, session_id: str, problem: str, user_answer: Optional[int], 
                     correct_answer: int, response_time_ms: int) -> bool:
        """Record a problem attempt in the session."""
        is_correct = user_answer == correct_answer
        
        # Create attempt record
        attempt = ProblemAttempt(
            id="",  # Will be generated by database
            session_id=session_id,
            problem=problem,
            user_answer=user_answer,
            correct_answer=correct_answer,
            is_correct=is_correct,
            response_time_ms=response_time_ms,
            timestamp=datetime.now()
        )
        
        # Save attempt
        saved_attempt = self.quiz_repo.save_attempt(attempt)
        if not saved_attempt:
            return False
        
        # Update session statistics
        return self.quiz_repo.increment_session_stats(session_id, is_correct)
    
    def complete_session(self, session_id: str) -> Optional[QuizSessionResult]:
        """Complete a quiz session and return results."""
        # Mark session as completed
        session = self.quiz_repo.complete_session(session_id)
        if not session:
            return None
        
        # Get all attempts for the session
        attempts = self.quiz_repo.get_session_attempts(session_id)
        
        # Calculate statistics
        if attempts:
            response_times = [attempt.response_time_ms for attempt in attempts]
            correct_times = [attempt.response_time_ms for attempt in attempts if attempt.is_correct]
            
            average_response_time = sum(response_times) / len(response_times)
            fastest_correct_time = min(correct_times) if correct_times else None
            slowest_correct_time = max(correct_times) if correct_times else None
        else:
            average_response_time = 0.0
            fastest_correct_time = None
            slowest_correct_time = None
        
        return QuizSessionResult(
            session=session,
            attempts=attempts,
            average_response_time=average_response_time,
            fastest_correct_time=fastest_correct_time,
            slowest_correct_time=slowest_correct_time
        )
    
    def abandon_session(self, session_id: str) -> bool:
        """Mark a session as abandoned."""
        session = self.quiz_repo.get_session(session_id)
        if not session:
            return False
        
        session.status = SessionStatus.ABANDONED
        session.end_time = datetime.now()
        
        updated_session = self.quiz_repo.update_session(session)
        return updated_session is not None
    
    def get_user_progress(self, user_id: str, limit: int = 10) -> UserProgress:
        """Get comprehensive user progress statistics."""
        # Get recent sessions
        recent_sessions = self.quiz_repo.get_user_sessions(user_id, limit=limit)
        completed_sessions = self.quiz_repo.get_user_sessions(user_id, limit=1000, status=SessionStatus.COMPLETED)
        
        if not completed_sessions:
            return UserProgress(
                total_sessions=0,
                total_problems=0,
                total_correct=0,
                overall_accuracy=0.0,
                average_session_time=0.0,
                best_accuracy=0.0,
                recent_sessions=recent_sessions
            )
        
        # Calculate statistics
        total_sessions = len(completed_sessions)
        total_problems = sum(session.total_problems for session in completed_sessions)
        total_correct = sum(session.correct_answers for session in completed_sessions)
        overall_accuracy = (total_correct / total_problems * 100) if total_problems > 0 else 0.0
        
        # Calculate average session time
        session_times = [
            session.duration_seconds for session in completed_sessions 
            if session.duration_seconds is not None
        ]
        average_session_time = sum(session_times) / len(session_times) if session_times else 0.0
        
        # Find best accuracy
        best_accuracy = max(session.accuracy for session in completed_sessions) if completed_sessions else 0.0
        
        return UserProgress(
            total_sessions=total_sessions,
            total_problems=total_problems,
            total_correct=total_correct,
            overall_accuracy=overall_accuracy,
            average_session_time=average_session_time,
            best_accuracy=best_accuracy,
            recent_sessions=recent_sessions
        )
    
    def get_session_details(self, session_id: str) -> Optional[QuizSessionResult]:
        """Get detailed session information including all attempts."""
        session = self.quiz_repo.get_session(session_id)
        if not session:
            return None
        
        attempts = self.quiz_repo.get_session_attempts(session_id)
        
        # Calculate statistics
        if attempts:
            response_times = [attempt.response_time_ms for attempt in attempts]
            correct_times = [attempt.response_time_ms for attempt in attempts if attempt.is_correct]
            
            average_response_time = sum(response_times) / len(response_times)
            fastest_correct_time = min(correct_times) if correct_times else None
            slowest_correct_time = max(correct_times) if correct_times else None
        else:
            average_response_time = 0.0
            fastest_correct_time = None
            slowest_correct_time = None
        
        return QuizSessionResult(
            session=session,
            attempts=attempts,
            average_response_time=average_response_time,
            fastest_correct_time=fastest_correct_time,
            slowest_correct_time=slowest_correct_time
        )